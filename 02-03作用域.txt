1. 对于变量的查找，抛出的异常总共有两种:
  第一种就是ReferenceError：代表在进行RHS查询的时候，也就是在查找值得时候没有查找到对应的变量，抛出的异常。（同作用域判断失败相关-）
  第二种就是TypeError：代表在对变量进行赋值的时候抛出的异常；比如对一个非函数类型的值进行函数调用。（代表作用域判别成功了，但是对结果的操作是非法或不合理的）
2. 作用域查找在找到第一个匹配的标识符时停止。
3. 无论函数在哪里被调用，也无论他如何被调用，他的词法作用域都只由函数被声明时所处的位置决定。
4. with函数中，我们通过是为了方便调用对象省略的写法，其实他跟我们的.操作符不一样（getter）；他是一个LHS查询，会进行赋值；在作用域中进行查找该变量。如果该对象没有属性，还是保持的是undefined。
5. eval函数如果接受了含有一个或多个声明的代码，救护修改其所处的词法作用域，而with声明实际上是根据你传递他的对象凭空创建了一个全新的词法作用域。（如果这个对象没有对应的属性，会执行LHS查询，如果全局都没有变量，那么会将这个属性添加到全局作用域中，），with的本质是通过将一个对象的引用当做作用域来处理的，将对象的属性当做作用域中的标识符来处理，从而创建一个新的词法作用域。、
6. 词法作用域意味着作用域是由写代码时函数声明的位置来决定的。编译的词法分析阶段基本能够知道全部标识符在哪里以及是如申明的，从而能够预测在执行过程中如何对他们进行查找。
7. 块级作用域：第一个就是可以使用with从对象中创建出的作用域仅在with声明中而非外部作用域中有效。第二个就是try/catch，catch分句会创建一个块作用域，其中声明的变量仅在catch内部有效。
8. 块级作用域可以进行垃圾回收：
  function process(data) {
    //todo
  }
  // 在这个块中定义的内容完事可以销毁
  {
    let something = {...}
	process(something)
  }
  var btn = document.getElementById('my_button')
  btn.addEventListener('click', function click() {
    //todo
  })
9. 词法作用域是一套关于引擎如何寻找变量以及会在何处找到变量的规则。词法作用域最重要的特征是他的定义过程发生在代码书写阶段。
10. 块级作用域替换：在es6之后出现了let以及const来定义块级作用域，但是在这之前是没有块级作用域的，但是try/catch从es3就开始存在了。catch里面可以形成块级作用域。所以在现在的大多数将es6转换为es5之前的代码时候处理块级作用域也是通过catch来实现的，如下面的代码：
 {
   try{
     throw undefined
   } catch(a) {
     a = 2
	 console.log(a)
   }
 }
 console.log(a)
 这里不用立即执行函数进行解决块级作用是因为，如果使用一个函数去包裹任意一部分代码，会改变这段代码的含义，其中的this、return、break和continue等都会发生变化。