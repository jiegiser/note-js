<!--
 * @Descripttion: 生成器章节
 * @Author: jiegiser
 * @Date: 2019-12-13 08:52:00
 * @LastEditors: jiegiser
 * @LastEditTime: 2019-12-17 08:39:12
 -->
# 生成器

生成器就是一类特殊的函数，可以一次或多次启动和停止，并不一定非得要完成。如下代码：
```js
var x = 1
function *foo() {
  x++
  yield
  console.log('x', x)
}
function bar() {
  x++
}
// 代码执行在yield就会暂停，我们可以使用next函数继续执行，如下
// 构造一个迭代器it来控制这个生成器
var it = foo()
// 这里启动foo
it.next()
x // 2
bar()
x // 3
it.next() // 3
```
上面代码的运行步骤：
1. `it = foo()`运算并没有执行生成器`*foo()`，而只是构造了一个迭代器（`iterator`），这个迭代器会控制他的执行。
2. 第一个`it.next()`启动了生成器`*foo()`，并运行了`*foo()`的第一行的`x++`
3. `*foo()`会在`yield`语句处暂停，在这一点上第一个`it.next()`调用结束。此时`*foo()`仍在运行并且是活跃状态的，但处于暂停状态。
4. 查看`x`的值是2
5. 调用`bar()`使得`x`递增
6. 查看`x`的值为3
7. 最后的`it.next()`调用从暂停处恢复了生成器`*foo()`的执行，并运行`console.log()`语句，打印结果值。

### 输入和输出

生成器跟普通函数是一样的，也是可以传递参数的，但是跟普通函数的区别就是并没有像普通函数一样实际运行，如下代码：

```js
function *foo(x, y) {
  return x * y
}
var it = foo(6, 7)
var res = it.next()
res.value // 42
```
`it`是一个迭代器对象，这个`next(..)`调用的结果是一个对象，他有一个`value`属性，持有从`*foo()`返回的值（如果有的话），换句话说，`yield`会导致生成器在执行过程中发送出一个值，这有类似`return`。

#### 迭代消息传递

生成器提提供了内建消息输入输出能力，通过`yield`和`next(..)`实现，如下代码：

```js
function *foo() {
  var y = x * (yield)
  return y
}
var it = foo(6)
// 启动foo()
it.next()
var res = it.next(7)
res.value // 42
```
在`*foo()`内部首先开始执行`x * ...`，随后遇到`yield`表达式，就会在赋值语句这里进行暂停，并在本质上要求调用代码为`yield`表达式提供一个结果值。接下来`it.next(7)`将值 7 传递给了暂停的`yield`表达式。

> 这里的`next`的调用跟`yield`并不是我们想象的那样对应的，需要的`next(..)`调用要比`yield`多一个。因为第一个`next(..)`总是启动一个生成器，并运行到第一个`yield`处。不过，是第二个`next(..)`调用完成第一个被暂停的`yield`表达式，第三个`next(..)`调用完成第二个`yield`，以此类推。

对于生成器，我们第一个启动生成器时一定要用不带参数的`next()`，因为规范和所有兼容浏览器都会默默丢弃传递给第一个`next(..)`的任何东西，第一个`next()`调用（没有参数的）基本上就是在提出一个问题：生成器`*foo()`要给我的下一个值是什么。执行到最后一个`next(..)`然后会执函数的`return`语句，如果函数没有`return`，就会执行假定的（隐式的）`return`，也就是`return undefined`