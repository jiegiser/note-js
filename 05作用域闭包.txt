1. 闭包：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行的。
   本质上，无论何时何地，如果将（访问他们各自词法作用域得）函数当做第一级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、ajax请求等中，我们会看到；其实就是只要使用了回调函数，实际就是在使用闭包；如下：
   function wait(message) {
     setTimeout(function timer(){
	   console.log(message)
	 }, 1000)
   }
   如上面的代码，在setTImeout函数中传入一个能够访问wait函数中所有的变量的作用域得函数。然后在setTImeout函数中的timer函数中可以进行访问wait函数中的变量。这就是闭包。
 
2. 闭包中典型的例子：--跟作用域以及异步有关
   for(var i = 1;i<=5;i++){
     setTimeout(function timer(){
	   console.log(i)
	 }, i*1000)
   }
   这里其实setTimeout函数是延迟执行的也就是说他是一种异步函数，他会将要执行的过程放在线程里面等待执行，因此在循环之后才会被执行，循环之后，的每一个timer函数都被封闭在一个共享的全局作用域中，因此实际上只有一个i，所以会打印出五次6；解决这个问题，我们可以给timer函数来封闭一个作用域，让他在塞到线程之后可以访问到之前的变量。所以我们这里就可以使用let 这种可以声明块级作用域，或者使用立即执行函数去解决这个问题。使得每次迭代都会有一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在迭代内部，每个迭代中都会含有一个具有正确的变量供我们使用。
3. 单例模式：就是将模块函数（也就是函数返回一个函数，返回的函数可以访问内部的属性）转换为了立即执行函数。并把这个立即执行函数直接赋值给一个变量（也就是所说的单例的模块实例标识符）。
4. 模块：在es6中新增了import以及export导入以及导出模块，模块文件中的内容会被当作好像包含在作用域闭包中一样来处理，这就跟函数闭包模块一样，返回一个函数，通过这个返回的函数来访问之前函数中的属性。9