# 语法

### 语句和表达式

每条语句执行完之后都是有结果值的，获得结果值最直接的方法就是在浏览器的控制台里面输入语句，默认情况下控制台会显示所执行的最后一句语句的结果。比如`var a = 42`，在控制台会显示`undefined`是因为规范定义`var`的结果值是`undefined`。

> es5 规范中变量声明算法实际上有一个返回值（是一个包含所声明变量名称的字符串。）但是这个值被变量语句算法屏蔽掉了（`for...in`语句除外），最后返回结果为空（`undefined`）

我们可以看下面代码语句的结果值：

```js
var b
if (true) {
  b = 4 + 38
}
```

在控制台输入之后，返回的结果为 42，也就是最后一个语句的结果值。也就是说，代码块的结果值将相当于一个隐式的返回。即最后一个语句的结果。

es7 有一个`do`表达式提案，如下代码：

```js
var a, b
a = do {
  if (true) {
    b = 4 + 38
  }
}
a // 42
```

上例中，`do{ ... }`表达式执行了一个代码块（包含一个或者多个语句），并且返回其中最后一个语句的结果值，然后赋值给`a`。这样做的目的就是将语句当做表达式来处理（语句中可以包含其他语句）。从而不需要将语句封装为函数在调用`return`来返回值。

#### 标签语句

如下代码：`foo`是语句`bar()`的标签

```js
{
  foo: bar()
}
```

他的作用是能够通过标签跳转实现`goto`的部分功能，`continue`以及`break`也可以带一个标签，因此能够像`goto`那样跳转，例如：

```js
// 标签为foo的循环
foo: for (var i = 0; i < 4; i++) {
  for (var j = 0; j < 4; j++) {
    // 如果j跟i相等，继续外层循环
    if (j === i) {
      // 跳转到foo的下一个循环
      continue foo
    }
    // 跳过奇数结果
    if ((j * i) % 2 === 1) {
      // 继续内层循环（没有标签的）
      continue
    }
    console.log(i, j)
  }
}
// 1 0
// 2 0
// 2 1
// 3 0
// 3 2
```

> `continue foo`并不是指跳转到标签`foo`所在的位置继续执行，而是执行`foo`的下一个循环。

带标签的循环跳转一个更大的用处在于，和`break _`一起使用可以实现从内层循环跳转到外层循环：

```js
// 标签为foo的循环
foo: for (var i = 0; i < 4; i++) {
  for (var j = 0; j < 4; j++) {
    if (i * j >= 3) {
      console.log('stopping', i, j)
      break foo
    }
    console.log(i, j)
  }
}
// 0 0
// 0 1
// 0 2
// 0 3
// 1 0
// 1 1
// 1 2
// stopping 1 3
```

> `break foo`不是指跳转到标签`foo`所在的位置继续执行，而是跳出标签`foo`所在的循环/代码块，继续执行后面的代码。

标签也能用于非循环代码块，但只有`break`才可以。我们可以对带标签的代码使用`break _`，但是不能对带标签的非循环代码使用`coninue _`，也不能对不带标签的代码块使用`break _`。

```js
// 标签为bar的代码块
function foo() {
  bar: {
    console.log('Hello')
    break bar
    console.log('never runs')
  }
  console.log('World')
}
```

`JSON`数据可以通过`JSON-P`将`JSON`数据封装成函数调用，来进行访问。`JSON-P`能将`JSON`转换为合法的`javascript`代码。

下面的有关代码块的一个坑：

```C#
[] + {} // "[object Object]"
{} + [] // 0
```

第一行代码中`{}`出现在`+`表达式中，因此他被当做一个值（空对象）来处理，`[]`被强制类型转换为`''`（是调用了`toString()`方法），而`{}`会转化为`"[object Object]"`

第二行代码中`{}`被当做一个独立的代码块（不执行任何操作），代码块结尾不需要分号，所以这里不存在语法上的问题。最后`+ []`会发生显示强制类型转换为 0（`+`运算符会发生强制类型转换）。

#### 对象结构

es6 新增了对象结构，如下代码：

```js
function getData() {
  return {
    a: 42,
    b: 'foo'
  }
}
var { a, b } = getData()
console.log(a, b) // 42, 'foo'
```

其中`{ a, b } =`相当于 `es6` 中的解构，相当于下面代码：

```js
var res = getData()
var a = res.a
var b = res.b
```

> 这里需要注意的是 `{ a, b }`实际是`{a: a, b: b}`的简化版本，这两种写法都可以。

对象结构还可以用在函数命名参数的对象解构：

```js
function foo({ a, b, c }) {
  // 不在需要这样
  // var a = obj.a, b = obj.b, c = obj.c
  console.log(a, b, c)
}
foo({ a: 42, b: 'foo', c: [1, 2, 3] })
// 42, 'foo', [1, 2, 3]
```

#### else if 和可选代码块

大部分人估计都跟我一样，以为`javascript`中有`else if`语句，读这本书才发现根本没有￣ □ ￣｜｜，我们会经常这样写：

```js
if (a) {
  // ..
} else if (b) {
  // ..
} else {
  // ..
}
```

上面是因为`if`和`else`只包含单条语句，省略了代码块的`{}`，比如我们会这样写代码：

```js
if (a) doSomething(a)
// 很多JavaScript代码检查工具建议我们加上{}
if (a) {
  doSomething(a)
}
```

`else` 也是一样，所以我们经常用到的`else if`实际是这样的：

```js
if (a) {
  // ..
} else {
  if (b) {
    // ..
  } else {
    // ..
  }
}
```

### 运算符优先级

要记住的是：用`,`连接一系列语句的时候，他的优先级最低，其他操作数的优先级都比他高。

`&`的优先级高于`=`的优先级，关于优先级的，如下代码：

```C#
var a = 42
var b = 'foo'
var c = false
var d = a && b || c ? c || b ? a : c && b : a
d // 42
```

其实对应的是下面的代码：

```js
var a = 42
var b = 'foo'
var c = false
var d = (a && b) || c ? (c || b ? a : c && b) : a
d // 42
```

从上面代码可以看出`&&`的运算符先于`||`。而`||`的优先级又高于`? :`运算法，可以从`mdn`上面查看详细的优先级规则：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence。
