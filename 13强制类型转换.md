# 强制类型转换


### 值类型转换

将值从一种类型转换为另一种类型通常称为类型转换，这个是显式的情况，隐式的情况称为强类型转换。
类型转换发生在静态类型语言的编译阶段，而强制类型转换则发生在动态类型语言的运行时。

### 抽象值操作
数组的默认`toString()`方法经过了重新定义，将所有单元字符串化后再用‘,’连接起来：
```js
var a = [1, 2, 3]
a.toString() // "1, 2, 3"
```

工具函数`JSON.stringify()`在将`JSON`对象序列化为字符串时也用到了`toString()`方法，对大多数简单值来说，`JSON`字符串化和`toString()`的效果基本相同，只不过序列化的结果总是字符串：
```js
JSON.stringify(42) // '42'
JSON.stringify('42') // ''42'' 含有双引号的字符串
JSON.stringify(true) // 'true'
```
`JSON.stringify()`在对象中遇到`undefined`、`Function`、`Symbol`时会自动忽略，在数组中则会返回`null`（以保证单元位置不变）：
```js
JSON.stringify(undefined) // undefined
JSON.stringify(function () {}) // undefined
JSON.stringify(
  [1, undefined, function () {}, 4]
) // '['1', null, null, 4]

JSON.stringify(
  { a: 2, b: function () {} } // "{'a': 2}"
)'
```
对包含循环引用的对象指向`JSON.stringify()`会出错。
> 注意，如果对象中定义了`toJSON()`方法，`JSON`字符串化时会首先调用这个方法，然后再用它的返回值来进行序列化。

如果需要对含有非法的`JSON`值（就是上面提到的`undefined`这些）得对象做字符串化，或者对象中的某些值无法被序列化时，就需要定义`toJSON()`方法来返回一个安全的`JSON`值：
```js
var o = {}
var a = {
  b: 42,
  c: o,
  d: function () {}
}
// 在a中创建一个循环引用
o.e = a

// 循环引用在这里会产生错误
// JSON.string(a)

// 自定义的JSON序列化
a.toJSON = function () {
  // 序列化仅包含b
  return { b: this.b }
}
JSON.stringify(a) // "{"b": 42}"
```
很多人以为`toJSON()`返回的是`JSON`字符串化后的值，其实不然，除非我们确实想要对字符串进行字符串化。`toJSON()`返回的应该是一个适当的值，可以是任何类型，然后再由`JSON.stringify()`对其进行字符串化。

也就是说，`toJSON()`应该返回一个能够被字符串化的安全的`JSON`值，而不是返回一个`JSON`字符串。例如：
```js
var a = {
  val : [1, 2, 3],
  // 可能使我们想要的结果
  toJSON: function () {
    return this.val.slice(1)
  }
}
var b = {
  val: [1, 2, 3],
  // 可能不是我们想要的结果
  toJSON: function () {
    return "[" + this.val.slice(1).join() + "]"
  }
}
JSON.stringify(a) // "[2, 3]"
// 对 toJSON 返回的字符串做字符串化，并不是数组本身
JSON.stringify(b) // ""[2, 3]""
```