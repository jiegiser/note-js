# 强制类型转换


### 值类型转换

将值从一种类型转换为另一种类型通常称为类型转换，这个是显式的情况，隐式的情况称为强类型转换。
类型转换发生在静态类型语言的编译阶段，而强制类型转换则发生在动态类型语言的运行时。

### 抽象值操作

#### toString

数组的默认`toString()`方法经过了重新定义，将所有单元字符串化后再用‘,’连接起来：
```js
var a = [1, 2, 3]
a.toString() // "1, 2, 3"
```

工具函数`JSON.stringify()`在将`JSON`对象序列化为字符串时也用到了`toString()`方法，对大多数简单值来说，`JSON`字符串化和`toString()`的效果基本相同，只不过序列化的结果总是字符串：
```js
JSON.stringify(42) // '42'
JSON.stringify('42') // ''42'' 含有双引号的字符串
JSON.stringify(true) // 'true'
```
`JSON.stringify()`在对象中遇到`undefined`、`Function`、`Symbol`时会自动忽略，在数组中则会返回`null`（以保证单元位置不变）：
```js
JSON.stringify(undefined) // undefined
JSON.stringify(function () {}) // undefined
JSON.stringify(
  [1, undefined, function () {}, 4]
) // '['1', null, null, 4]
JSON.stringify(null) // 'null'
JSON.stringify(
  { a: 2, b: function () {} } // "{'a': 2}"
)'
```
对包含循环引用的对象指向`JSON.stringify()`会出错。
> 注意，如果对象中定义了`toJSON()`方法，`JSON`字符串化时会首先调用这个方法，然后再用它的返回值来进行序列化。

如果需要对含有非法的`JSON`值（就是上面提到的`undefined`这些）得对象做字符串化，或者对象中的某些值无法被序列化时，就需要定义`toJSON()`方法来返回一个安全的`JSON`值：
```js
var o = {}
var a = {
  b: 42,
  c: o,
  d: function () {}
}
// 在a中创建一个循环引用
o.e = a

// 循环引用在这里会产生错误
// JSON.string(a)

// 自定义的JSON序列化
a.toJSON = function () {
  // 序列化仅包含b
  return { b: this.b }
}
JSON.stringify(a) // "{"b": 42}"
```
很多人以为`toJSON()`返回的是`JSON`字符串化后的值，其实不然，除非我们确实想要对字符串进行字符串化。`toJSON()`返回的应该是一个适当的值，可以是任何类型，然后再由`JSON.stringify()`对其进行字符串化。

也就是说，`toJSON()`应该返回一个能够被字符串化的安全的`JSON`值，而不是返回一个`JSON`字符串。例如：
```js
var a = {
  val : [1, 2, 3],
  // 可能使我们想要的结果
  toJSON: function () {
    return this.val.slice(1)
  }
}
var b = {
  val: [1, 2, 3],
  // 可能不是我们想要的结果
  toJSON: function () {
    return "[" + this.val.slice(1).join() + "]"
  }
}
JSON.stringify(a) // "[2, 3]"
// 对 toJSON 返回的字符串做字符串化，并不是数组本身
JSON.stringify(b) // ""[2, 3]""
```

我们可以向`JSON.stringify()`传递一个可选参数`replacer`，他可以是数组或者函数，用来指定对象序列化过程中哪些属性应该被处理，哪些属性应该被排除，和`toJSON`很像。

如果`replacer`是一个数组，那么它必须是一个字符串和数组，其中包含序列化要处理的对象的属性名称，除此之外其他的属性则被忽略。

如果`replacer`是一个函数，他会对对象本身调用一次，然后对对象中的每个属性各调用一次，每次传递两个参数，键和值。如果要忽略某个键就返回`undefined`，否则返回指定的值。

```js
var a = {
  b: 42,
  c: '42',
  d: [1, 2, 3]
}
JSON.stringify(a, ['b', 'c']) // "{"b": 42, "c": "42"}"
JSON.stringify(a, function (k, v) {
  if (k !== "c") return v
})
// "{"b": 42, "d": [1, 2, 3]}"
```
> 如果`replace`是函数，他的参数`k`在第一次调用时为`undefined`（就是对象本身调用的那次）。`if`语句将属性`"c"`排除掉。由于字符串化时递归的，因此数组`[1 2, 3]`中的每个元素都会通过参数`v`传递给`replacer`，也就是 1， 2，3，参数`k`是他的索引值：0，1，2。

`JSON.stringify()`还有一个可选参数`space`，用来指定输出的缩进格式。`space`为正整数时是指定每一级缩进的字符数，他可以是字符串：

```js
var a = {
  b: 42,
  c: '42',
  d: [1, 2, 3]
}
JSON.stringify(a, null, 3)
// "{
//   "b": 42,
//   "c": '42',
//   "d": [
//     1,
//     2,
//     3
//   ]
// }"

JSON.stringify(a, null, '---')
// "{
// ---"b": 42,
// ---"c": '42',
// ---"d": [
// ------1,
// ------2,            
// ------3
//---]
// }"
```
`JSON.stringify()`并不是强制类型转换：
* 字符串、数字、布尔值和`null`的`JSON.stringify`规则跟`toString`基本相同。
* 如果传递给`JSON.stringify()`的对象中定义了`toJSON`方法，那么该方法会被字符串化前调用，以便将对象转换为安全的`JSON`值。

#### ToNumber

其中`true`转换为 1 ，`false`转换为0，`undefined`转换为`NaN`,`null`转换为0。
转换`Number`跟`JSON.stringify`也是差不多，他首先会去检查值是否有`valueOf`方法，如果有并且返回基本类型值，就是用该值进行强制类型转换，如果没有就使用`toString`的返回值（如果存在）来进行强制类型转换。
如果`valueOf()`和`toString()`均不返回基本类型值，会产生`TypeError`错误。例如：

下面的例子我们假定`Number`已经实现了强制类型转换。
```js
var a = {
  valueOf: function () {
    return "42"
  }
}
var b = {
  toString: function () {
    return "42"
  }
}
var c = [4, 2]
c.toString = function () {
  return this.join('') // 42
}
Number(a) // 42
Number(b) // 42
Number(c) // 42
Number('') // 0
Number([]) // 0
Number([ 'abc' ]) // NaN
```

#### ToBoolean

下面的值都可以转换为`false`:
* undefined
* null
* ''
* false
* +0、-0和NaN

### 显式强制类型转换

#### 字符串和数字之间的显式转换

下面是两者之间的显式强制类型转转：

```js
var a = 42
var b = String(a)
var c = '3.14'
var d = Number(c)
b // '42'
d // 3.14
```
除了`String(..)`和 `Number(..)`以外，还有其他方法可以实现字符串和数字之间的显式转换：
```js
var a = 42
var b = a.toString()
var c = '3.14'
var d = +c
b // '42'
d // 3.14
```

一元运算符`+`的另一个常见用途是将日期`Date`对象强制类型转换为数字，返回结果为`Unix`时间戳，以毫秒为单位：
```js
var d = new Date("Mon, 18 Aug 2014 08:53:06 CDT")
+d // 14083669986000
// 我们一般使用下面的方法来获得当前的时间戳
var timestamp = +new Date()
```
`JavaScript`中的字符串的`indexOf`方法在字符串中搜索指定的字符串，如果找到就返回子字符串所在的位置（从0开始）否则返回-1。
`indexOf`不仅能够得到子字符串的位置，还可以用来检测字符串中是否包含指定的子字符串。相当于一个判断：
```js
var a = 'Hello World!'
if (a.indedOf('lo') >= 0) {
  // 找到匹配
}
if (a.indexOf('lo') != -1) {
  // 找到匹配
}
if (a.indeOf('ol') < 0) {
  // 没有找到匹配
}
if (a.indexOf('ol') == -1) {
  // 没有找到匹配
}
```

一般我们使用`indexOf`来判断是否找到对应的子字符串，都是判断是不是大于-1，其实我们可以使用`~`操作符，他是执行`ToInt32`并反转字符，就是会对数字加1，比如`~-1`的结果就是0，他是字位操作符。所以我们可以使用`if(~a.indexOf())`这样来改写上面我们的判断。

> `~`要比`>=0`和`==`更简洁

有的人会使用`~~`来截除数字值的小数部分，以为这个和`Math.floor`效果是一样的，其实并不是，`~~`中的第一个`~`是执行`ToInt32`并反转字符，然后第二个`~`再进行一次字位反转，也就是将所有字位反转回原值。最后得到的任然是`ToInt32`的结果。

> `~~` 与`x | 0`   都可以将一个值截除为一个32位的整数。

#### 显式解析数字字符串

解析字符串中的数字和将字符串强制转换为数字的返回结果都是数字，但是解析和转化两者还是有很大的差别的：
```js
var a = '42'
var b = '42px'
Number(a) // 42
parseInt(b) // 42
```
解析允许字符串中含有非数字字符，解析按照从左到右的顺序，如果遇到非数字字符，就会停止。而转换不允许出现非数字字符。否则会失败返回 `NaN`。
`parseInt()`会将参数强制类型转换为字符串，再进行解析。也就是说他会执行参数的`toString()`方法：
```js
var a = {
  num: 2,
  toString: function () {
    return String(this.num * 2)
  }
}
psrseInt(a) // 4
```
上面的代码也是可以执行的。但是如果参数对象有`valueOf`方法是不会执行这个方法的。

> 但是`parseInt(1/0, 19)`这个结果却是18，我们会想到`1/0`是`infinity`怎么回事。。实际上`parseInt()`方法的第二个参数是设置为基数的，也就是设置转换为那种类型，比如八进制或者十六进制的数字。但是显然我们并没有19进制的数值。`parseInt(1/0, 19)`实际上是`parseInt('Infinity', 19)`，第一个字符是`I`，以19为基数时值为18,。第二个字符`n`不是一个有效数字字符，解析到此为止（也就类似于`42px`中的`p`）。

知道了上面的解析过程，我们就明白了`parseInt()`是怎么实现转换的，下面的结果也就解释的通了：

```js
parseInt(0.000008) // 0 ("0" 来源于 "0.000008")
parseInt(0.0000008) // 8 ("8" 来源于 "8e-7")
parseInt(false, 16) // 250 ("fa" 来源于 "false")
parseInt(parseInt, 16) // 15 ("f" 来源于 "Functioin..")
parseInt("0x10") // 16
parseInt('102', 2) // 2
```

#### 显式解析数字字符串

与前面的`String()`和`Number()`一样，`Boolean()`（不带`new`）是显示的`ToBoolean`强制类型转换：
```js
var a = '0'
var b = []
var c = {}
var d = ''
var e = 0
var f = null
var g
Boolean(a) // true
Boolean(b) // true
Boolean(c) // true
Boolean(d) // false
Boolean(e) // false
Boolean(f) // false
Boolean(g) // false
```
> 这里需要注意的是 `Boolean('')`为`false`，一元运算符`+`，也会进行强制类型转换，比如`+'13.2'`返回的结果是`13.2`。

和前面说过的`+`类似，一元运算符`!`显式地将值强制类型转换为布尔值。但是他同时还将真值反转为假值。所以显示强制类型转换为布尔值最常用的方法时`!!`，因为第二个`!`会将结果反转回原值：

```js
var a = '0'
var b = []
var c = {}
var d = ''
var e = 0
var f = null
var g
!!a // true
!!b // true
!!c // true
!!d // false
!!e // false
!!f // false
!!g // false
```
如果有`if`语句，如果没有`Boolean()`或者`!!`，就会自动隐式地进行`ToBoolean`转换。建议每次进行显式的进行转换。

显式的`ToBoolean`的另外一个用处，是在`JSON`序列化过程中将值强制类型转换为`true`或者`false`：

```js
var a = [
  1,
  function () { /**/ },
  2,
  function () { /**/ }
]
JSON.stringify(a) // "[1, null, 2, null]"
JSON.stringify(a ,function (key, val) {
  if (typeof val === "function") {
    return !!val
  } else {
    return val
  }
})
// "[1, true, 2, true]"
```

### 隐式强制类型转换