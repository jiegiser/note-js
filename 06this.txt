1. 匿名函数的缺点：
  第一：匿名函数在栈追踪中不会系那是出有意义的函数名，使得调试很困难。需要引用 第二：如果没有函数名，当函数需要引用自身时只能使用已经过期的arguments.callee引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。
  第三：匿名函数省略了对于代码可读性/可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。始终给函数表达式命名是一个最佳实践。
2. this在任何情况下都不指向函数的词法作用域。
3. 箭头函数的this指向：是在词法分析阶段就对this进行了绑定。也就是绑定到该属性的词法作用域。
4. this是什么：当一个函数被调用时，会创建一个执行上下文，这个执行上下文包含一些函数在哪里被调用（调用栈）、函数的调用方式、传入的参数信息等等，this就是这个记录的一个属性，会在函数执行的过程中用到。this实际上是在函数被调用时发生绑定，他指向什么完全取决于函数在哪里被调用。
5. this的指向：
  第一是指向对象属性引用链中的上一层，或者说是最后一层的调用位置。
  第二是不管是函数别名去引用一个函数地址还是参数传递到一个函数内部（将一个函数以参数的形式进行传递），这种就是被隐式绑定的函数会丢失绑定对象。最终看在哪里调用，this就指向那个调用的上下文。如下
  function foo() {
    console.log(this.a)
  }
  var obj = {
    a: 2,
	foo: foo
  }
  var bar = obj.foo//函数别名
  var a = 'opps, global'
  bar() // 'opps global'--丢失了绑定对象。
  
  下面的代码也一样
  function foo() {
    console.log(this.a)
  }
  function doFoo(fn){
    // fn其实引用的是foo
	fn()// 调用位置
  }
  var a = 'opps, global'
  doFoo(obj.foo) // 'opps global'--丢失了绑定对象。
6. bind函数：foo.bind(obj)就是将指定的参数这里就是obj，为foo执行的上下文。this是指向obj的，他其实就是跟apply或者call方法一样用于绑定，只不过他是在函数的原型上添加了这个方法。Function.prototype.bind；
7. 使用new关键字来调用函数，会自动执行下面的操作：
   第一、创建（或者说构造）一个全新的对象。
   第二、这个新对象会被执行[[Prototype]]连接
   第三、这个新对象会绑定到函数调用的this
   第四、如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。
   如下面代码：
   function foo(a){
     this.a = a
   }
   var bar = new foo(2)
   console.log(bar.a)//2
   使用new来调用foo时候，我们会构造一个新对象并把它绑定到foo()调用中的this上。而bar就是执行这个新对象。
8. this的绑定：
    他有四种方式进行绑定：默认绑定、隐式绑定、显示绑定、new绑定。
	new绑定会修改this的指向，比如new的对象是一个硬绑定（foo.bind()）这样，就会修改bind中绑定的this指向的对象。然后会创建一个新的对象指向实例化的对象。
9. 判断this：
  第一：函数是否在new中调用（new绑定）？如果是的话，this绑定的是新创建的对象。
    var bar = new  foo()
  第二：函数是否通过call、apply（显示绑定）或者硬绑定（Function.prototype.bind）调用？如果是的话，this绑定的是那个上下文对象。
    var bar = foo.call(obj2)
  第三：函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this绑定的是那个上下文对象。
    var bar = obj1.foo()
  第四：如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到全局对象。
    var bar = foo()
10. 绑定的例外：
  如果我们将null或者undefined的绑定对象传入call、apply、或者bind，这些值在调用的时候会被忽略，实际应用的是默认绑定的规则，就是绑定到全局变量。
  例如下面的代码：
  function foo(a, b) {
    console.log('a:'+a+'b:'+b)
  }
  // 把数组展开成参数
  foo.apply(null, [2, 3])//a:2,b:3
  
  // 使用bind进行柯里化
  var bar = foo.bind(null, 2)
  bar(3)//a:2,b:3
  
  不过我们有时候不需要传入一个有意义的对象去指定this的绑定，我们才会传入null或者undefined，为了避免传入null或者undefined导致bug，我们会使用Object.create创建一个空对象，去使用；比如下面的代码：
  function foo(a, b) {
    console.log('a:'+a+'b:'+b)
  }
  // 我们创建一个空对象
  var nullObj = Object.create(null)
  // 把数组展开成参数
  foo.apply(nullObj, [2, 3])//a:2,b:3
  
  // 使用bind进行柯里化
  var bar = foo.bind(nullObj, 2)
  bar(3)//a:2,b:3
11. 间接引用
   如下面代码：
   function foo() {
     console.log(this.a)
   }
   var a = 2
   var o = { a: 3, foo: foo}
   var p = { a: 4}
   o.foo()//3
   (p.foo = o.foo)()//2
   赋值表达式p.foo = o.foo的返回值是目标函数的引用，因此调用位置是foo()而不是p.foo()或者o.foo(),所以使用的是默认绑定。
   注意：对于默认绑定，决定this绑定对象的并不是调用位置是否处于严格模式，而是函数体是都处于严格模式。如果函数体处于严格模式，this会绑定到undefined，否则this会被绑定到全局对象。
12. 箭头函数
  箭头函数不是使用this的四种标准规则，而是根据外层（函数或者全局）作用域来决定this的。
  例如下面代码：
  function foo() {
    // 返回一个箭头函数
	return (a) => {
	  // this继承自foo
	  console.log(this.a)
	}
  }
  var obj1 = {
    a: 2
  }
  var obj2 = {
   a: 3
  }
  var bar = foo.call(obj1)
  bar.call(obj2)// 2而不是3
  foo()内部创建的箭头函数会捕获调用时foo()的this。由于foo()的this绑定到obj1，bar（引用箭头函数）的this也会绑定到obj1，箭头函数的绑定无法被修改。(new也是不行)