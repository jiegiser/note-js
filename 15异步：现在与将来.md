# 异步：现在与将来

### 分块的程序

可以将`javascript`程序写在单个`.js`文件中，但是这个程序机会一定是由多个块构成的。这些块中只有一个是现在执行的，其余的则是会在将来执行。最常见的块单位就是函数。

任何时候，只要把一段代码包装成一个函数，并指定他在响应某个事件（定时器、鼠标点击、`Ajax`响应等）时执行，你就是在代码中创建了一个将来执行的块，也由此在这个程序中引入了异步机制。

---

### 异步控制台

有时候我们在控制台打印东西，可能不是我们预想的结果，如下代码：

```js
var a = {
  index: 1
}
// 然后
console.log(a)
// 在然后
a.index++
```

我们会以为输出的是 1，但是这段代码在运行的时候，浏览器可能会认为需要把控制台`I/O`延迟到后台，在这种情况下，等到浏览器控制台输出对象内容时候，`a.index++`可能已经指向，因此会显示`{index: 2}`。

> 我们如果遇到这种情况，可以使用`javscript`调试器中的断点，而不要依赖控制台输出。次优方案是把对象序列化到一个字符串中，以强制执行一次“快照”，比如通过`JSON.stringify(...)`。

---

### 事件循环

在 es6 之前，`javascript`是不存在异步的，`javascript`引擎本身只是在需要的时候，在给定的任意时刻执行程序中的单个代码块。`javascript`引擎本身并没有时间的概念，只是一个按需执行`javascript`任意代码片段的环境。事件（`javscript`代码执行）调度总是由包含他的环境进行，例如下面的伪代码：

```js
// eventLoop是一个用作队列的数组
// （先进先出）
var eventLoop = []
var event
// 永远执行
while (true) {
  // 一次tick
  if (eventLoop.length > 0) {
    // 拿到队列中的下一个事件
    event = eventLoop.shift()
    // 现在执行下一个事件
    try {
      event()
    } catch (err) {
      reportError(err)
    }
  }
}
```

上面代码循环的每一轮称为一个`tick`，对每个`tick`而言，如果在队列中有等待事件，那么就会从队列中摘下一个事件并执行。这些事件就是你的回调函数。

一定要清楚，`setTimeout`并没有将回调函数挂在事件循环队列中，它所做的是设定一个定时器。当定时器到的时候，环境会把你的回调函数放在事件循环中。这样，在未来的某一刻的`tick`会摘取并执行这个回调。

如果这个循环队列中有很多，那么他们会等待执行，这也解释了`setTimeout`定时器的精度不高的原因。他只能确保你的回调不会在指定的时间之前执行，具体在哪个时刻执行，要根据时间队列的状态而定。

---

### 并行线程

异步跟并行常常混为一谈，但实际上他们的意义完全不同，异步是关于现在跟将来之间的时间间隙，而并行是关于能够同时发生的事情。

多线程编程是非常复杂的。如果不通过特殊的步骤来防止这种中断跟交错运行的话，代码运行可能会得到出乎意料的、不确定的行为。
`javascript`从不跨线程共享数据。这意味着不需要考虑这一层的不确定性，但这个并不是意味着`javascript`总是确定性的。如下代码：

```js
var a = 20
function foo() {
  a = a + 1
}
function bar() {
  a = a * 2
}
// ajax是某一个库中提供的某个ajax函数
ajax('http://some.url.1', foo)
ajax('http://some.url.2', bar)
```

根据`JavaScript`单线程运行的特性，如果`foo()`运行在`bar()`之前，`a`的结果是 42，如果`bar()`在`foo()`之前，`a`的结果是 41。

---

### 任务

在 es6 中，有一个新的概念简历在事件循环队列之上，叫做任务队列，这个概念也带来了`Promise`的异步特性。任务队列是挂在事件循环队列的每个`tick`之后的一个队列。在事件循环的每个`tick`中，可能出现的异步动作不糊导致一个完整的新事件添加到事件循环队列中，而会在当前`tick`的任务队列末尾添加一个项目（一个任务）。
