# 回调

`javascript`中并不存在并发，而是在一个进程中（也就是一个事件中）执行任务的快速切换，使得导致人们以为是在并发执行事件。

回调表达程序异步和管理并发的两个主要缺陷：缺乏顺序性和可信任性。

# Promise

一旦`Promise`决议，他就永远保持这个状态。此时他就称为了不变值，可以根据需求多次查看。`Promise`是一种封装和组合未来值得易于复用的机制。

如果你试图使用恰好有`then(..)`函数的一个对象或函数值完成一个`Promise`，但是并不希望他被当做`Promise`或`thenable`，那就有点麻烦了，因为他会自动识别为`thenable`，并被按照特定的规则处理。这就说明，我们的对象或者函数补鞥呢拥有`then(..)`函数，否则这个值在`Promise`系统中就会被误认为是一个`thenable`，这可能会导致难以追踪的`bug`，有些早期实现`Promise`机制的库就会改变自己本来有的`then(..)`方法，而有的就会直接说明：与基于`Promise`的库不兼容。

> 什么是 thenable 对象 ？

```js
let thenable = {
  then: function(resolve, reject) {
    resolve(42)
  }
}
```

我们使用异步回调函数可能会出现的问题：

- 调用回调过早
- 调用回调过晚（或不被调用）
- 调用毁掉词汇过少或过多
- 未能传递所需的环境和参数
- 吞掉可能出现的错误异常

`Promise`的特性就是专门用来为这些问题提供一个有效的可复用的答案。
