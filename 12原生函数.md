# 原生函数

常见的原生函数有：
* String()
* Number()
* Boolean()
* Array()
* Object()
* Function()
* Regex()
* Date()
* Error()
* Symbol()

原生函数可以当做构造函数来使用，但其构造出来的对象可能会和我们设想的有所出入：
```js
var a = new String('abc')
typeof a // 是'object'，不是'String'
a instanceof String // true
Object.prototype.toString.call(a) 
// '[object object]'
```
> 注意`typeof`这里返回的是对象类型的子类型。`new String('abc')`创建的是字符串`'abc'`的封装对象，而非基本类型`'abc'`

---

### 内部属性

所有`typeof`返回值为`object`的对象（如数组）都包含一个内部属性`[[class]]`，可以把它看做是一个内部的分类。这个属性无法直接访问，我们可以通过下面的方法来访问：
```js
Object.prototype.toString.call([1, 2, 3])
// [object Array]

Object.prototype.toString.call(/regex-literal/i)
// [object Regex]
```
可以看出数组的内部`[[class]]`为`'Array'`，正则表达式的是`'Regex'`。多数情况下，对象的内部`[[class]]`属性和创建该对象的内建原生构造函数相对应，但也有特殊，如下：
```js
// 基本类型中的 null 以及 undefined
Object.prototype.toString.call(null)
// [object Null]

Object.prototype.toString.call(undefined)
// [object Undefined]
```
虽然`Null()`跟`Undefined()`这样的原生构造函数并不存在，但是内部`[[class]]`属性却是这种。

其他基本类型的情况也是有所不同，通常称为包装：
```js
Object.prototype.toString.call('abc')
// [object String]
Object.prorotype.toString.call(41)
// [object Number]
Object.prototype.toString.call(true)
// [object Boolean]
```
上面的例子中基本类型值被各自的封装对象自动包装，所以他们的内部`[[class]]`属性分别是`String Number Boolean`

---

### 封装对象包装
由于基本类型没有`.length`和`.toString()`这样的属性以及方法。需要通过封装对象才能访问。此时`javascript`会自动为基本类型值包装一个封装对象：
```js
var a = 'abc'
a.length // 3
a.toUpperCase() // 'ABC'
```

---

### 拆封
如果想要得到封装对象中的基本类型值，可以使用`valueOf()`函数：
```js
var a = new String('abc')
var b = new Number(42)
var c = new Boolean(true)

a.valueOf() // 'abc'
b.valueOf() // 42
c.valueOf() // true
```
在需要用到封装对象中的基本类型值得地方会发生隐式拆封（也就是强制类型转换）：
```js
var a = new String('abc')
var b = a + '' // b的值为'abc'
typeof a // 'object'
typeof b // 'string'
```

---

### 原生函数作为构造函数

有关数组、正则、对象、函数，我们一般都是喜欢用常量的形式来创建他们。实际上，使用常量和使用构造函数的效果是一样的。（创建的值都是通过封装对象类包装的）。

#### Array()
```js
var a = Array(1, 2, 3)
a // [1, 2, 3]
var b = [1, 2, 3]
b // [1, 2, 3]
```
> 构造函数`Array()`不要求必须带`new`关键字。不带时，他会自动补上，因此`Array(1, 2, 3)`跟`new Array(1, 2, 3)`的效果是一样的。

如果`Array()`构造函数只带一个数字参数的时候，该参数会被作为数组的预设长度，而并非指充当数组的一个元素。
这里有一个如果在数组中输入`[, , , ]`我们会认为他是代表了四个元素；在es5规范开始就允许在列表（数组值、属性列表等）末尾多加一个逗号（在实际处理中会被忽略不计）。所以如果你在代码或者调试控制台中输入`[, , , ]`，实际得到的是`[, ,]`（包含三个空单元的数组）。

还有下面特殊情况：
```js
var a = new Array(3)
var b = [undefined, undefined, undefined]
a.join('-') // "--"
b.join('-') // "--"
a.map(function (v, i) { return i }) 
// [empty × 3]
b.map(function (v, i) { return i })
// [0, 1, 2]
```
`a.map()`之所以执行失败，是因为数组中并不存在任何单元，所以`map`无从遍历。而`join()`却不一样，他的具体实现如下代码：
```js
function fakeJoin(arr, connector) {
  var str = ''
  for (var i = 0; i< arr.length; i++) {
    if (i > 0) {
      str += connector
    }
    if (arr[i] !== undefined) {
      str += arr[i]
    }
  }
  return str
}
var a = new Array(3)
fakeJoin(a, '-')
```
从中可以看到`join`首先假定数组不为空，然后通过`length`属性值来遍历其中的元素。而`map()`并不做这样的假定，因此结果也往往不同。

我们可以通过下面的方法来创建包含`undefined`单元（而非空单元）的数组：
```js
var a = Array.apply(null, { length: 3 })
a // [undefined, undefined, undefined]
```
`apply()`方法的第二个参数是一个类数组对象，其中的值被当做函数的参数。可以设想`Array.apply()`内部有一个`for`循环，并且将`{length: 3}`作为函数的参数。从0开始循环到`length`（也就是循环到2不包含3）；假设`apply()`内部该数组参数名为`arr`，`for`循环就会这样遍历数组，`arr[0]、arr[1]、arr[2]`然而由于`{length: 3}`并不存在这些属性（也就是说这个对象不存在属性0， 1， 2），所以返回的是`undefined`、

#### Object(...)、Function(...)和RegExp(...)

```js
var c = new Object()
c.foo = 'bar'
c // { foo: 'bar' }
var d = { foo: 'bar' }
d // { foo: 'bar' }

```
如果在实际中没有必要使用`new`关键字来创建上面的这些对象，就尽量避免使用。因为这样就无法像常量形式那样一次设定多个属性，而必须逐一进行设定。
