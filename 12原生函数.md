# 原生函数

常见的原生函数有：
* String()
* Number()
* Boolean()
* Array()
* Object()
* Function()
* Regex()
* Date()
* Error()
* Symbol()

原生函数可以当做构造函数来使用，但其构造出来的对象可能会和我们设想的有所出入：
```js
var a = new String('abc')
typeof a // 是'object'，不是'String'
a instanceof String // true
Object.prototype.toString.call(a) 
// '[object object]'
```
> 注意`typeof`这里返回的是对象类型的子类型。`new String('abc')`创建的是字符串`'abc'`的封装对象，而非基本类型`'abc'`

---

### 内部属性

所有`typeof`返回值为`object`的对象（如数组）都包含一个内部属性`[[class]]`，可以把它看做是一个内部的分类。这个属性无法直接访问，我们可以通过下面的方法来访问：
```js
Object.prototype.toString.call([1, 2, 3])
// [object Array]

Object.prototype.toString.call(/regex-literal/i)
// [object Regex]
```
可以看出数组的内部`[[class]]`为`'Array'`，正则表达式的是`'Regex'`。多数情况下，对象的内部`[[class]]`属性和创建该对象的内建原生构造函数相对应，但也有特殊，如下：
```js
// 基本类型中的 null 以及 undefined
Object.prototype.toString.call(null)
// [object Null]

Object.prototype.toString.call(undefined)
// [object Undefined]
```
虽然`Null()`跟`Undefined()`这样的原生构造函数并不存在，但是内部`[[class]]`属性却是这种。

其他基本类型的情况也是有所不同，通常称为包装：
```js
Object.prototype.toString.call('abc')
// [object String]
Object.prorotype.toString.call(41)
// [object Number]
Object.prototype.toString.call(true)
// [object Boolean]
```
上面的例子中基本类型值被各自的封装对象自动包装，所以他们的内部`[[class]]`属性分别是`String Number Boolean`

---

### 封装对象包装
由于基本类型没有`.length`和`.toString()`这样的属性以及方法。需要通过封装对象才能访问。此时`javascript`会自动为基本类型值包装一个封装对象：
```js
var a = 'abc'
a.length // 3
a.toUpperCase() // 'ABC'
```

---

### 拆封
如果想要得到封装对象中的基本类型值，可以使用`valueOf()`函数：
```js
var a = new String('abc')
var b = new Number(42)
var c = new Boolean(true)

a.valueOf() // 'abc'
b.valueOf() // 42
c.valueOf() // true
```
在需要用到封装对象中的基本类型值得地方会发生隐式拆封（也就是强制类型转换）：
```js
var a = new String('abc')
var b = a + '' // b的值为'abc'
typeof a // 'object'
typeof b // 'string'
```

---

### 原生函数作为构造函数

有关数组、正则、对象、函数，我们一般都是喜欢用常量的形式来创建他们。实际上，使用常量和使用构造函数的效果是一样的。（创建的值都是通过封装对象类包装的）。

#### Array()
```js
var a = Array(1, 2, 3)
a // [1, 2, 3]
var b = [1, 2, 3]
b // [1, 2, 3]
```
> 构造函数`Array()`不要求必须带`new`关键字。不带时，他会自动补上，因此`Array(1, 2, 3)`跟`new Array(1, 2, 3)`的效果是一样的。

如果`Array()`构造函数只带一个数字参数的时候，该参数会被作为数组的预设长度，而并非指充当数组的一个元素。